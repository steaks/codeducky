10 functions no .NET developer should be without

* general-purpose
Throw.if
nullsafe
capped / getvalues<T> / ToDelimitedString()
as
traverse

* collections
equalitycomparers
collectionequals
getoradd

* reflection
getproperty (should do getMethod)
getgenericarguments

IDEAS:
* Equality in C#
* LinqPad as a .NET developer's command prompt
	* scripting examples -> file processing with LINQ, XML, JSON, Regex processing
	* building in your own utilities & backend
	* reflection-aware code generation (e. g. immutable version of a type, visitor pattern)
* EqualityComparers
	* Create
	* ReferenceComparer

- deliberately concise, full version for download
- don't claim originality
- break into 2 parts

[TODO group by "category"]
reflection, collections, missing language concepts

[TODO make this a post of it's own in the future]
* Throw<TException>.If
Assertions, argument checks, and other validity tests are a vital part of programming, but they can be surprisingly painful in C#. Debug.Assert() comes out of the box, but only works in a DEBUG build and doesn't let you specify the type of exception to be thrown. Meanwhile, spending 3 lines per check on if (...) { throw new ... } with Allman [TODO link] braces gets cumbersome very quickly. Throw<T>.If is a simple method that makes it easy to do 1-liner checks while still maintaining the flexibility of using different exception types:

<pre>
public static class Throw<TException> where TException : Exception
{
    public static void If(bool condition, string message) 
	{
		if (condition)
		{
			throw (TException)Activator.CreateInstance(typeof(TException), message);
		}
	}
}
</pre>

Why is the generic parameter on the type and not the method? It could clearly go in either place, but I chose to place it on the type since it leads to the most natural English
reading of the code "Throw ArgumentException If a == null" instead of "Throw If ArgumentException a == null".

* NullSafe()
Null values are a frustrating fact of life in C#, and checking for them frequently breaks the natural cadence of coding. You just want to write foo.GetBar().Baz.SomeMethod(), but checking for null at each step along the way turns this concise chain of calls into an ugly sequence of ifs and curly braces. The NullSafe function allows these checks to happen more or less inline, maintaining the structure of the code while dodging NullReferenceExceptions:

<pre>
public static TResult NullSafe<TObj, TResult>(this TObj obj, Func<TObj, TResult> func, TResult ifNullReturn = default(TResult))
{
	return obj != null ? func(obj) : ifNullReturn;
}
</pre>

With this extension, the above chain might be re-written as: [TODO lifting/monads?]
<pre>
foo.NullSafe(f => f.GetBar())
	.NullSafe(b => b.Baz)
	.NullSafe(b => b.SomeMethod(), ifNullReturn: "whatever you would return in the null case");
</pre>
To support invoking void methods at the end of the chain, just add an overload that takes Action<TObj> instead of Func<TObj>.

* GetProperty()
Reflection is a powerful aspect of .NET, and vital for many tasks like model binding, serialization, and processing expression trees. However, I've always been frustrated by the fact that using reflection makes code harder to refactor since your method and property names end up as strings. This method leverages Expression lambdas to allow for type-safe retrieval of properties.

<pre>
public static PropertyInfo GetProperty<TProperty>(Expression<Func<TProperty>> expr)
{
	return (PropertyInfo)((MemberExpression)expr.Body).Member;
}
</pre>

From here, it's easy to build overloads to for type-safely retrieving MethodInfos (which is especially useful because you can get the compiler to do overload resolution for you).

* EqualityComparers.Create(equals, hash), mention by key

Most of the built-in .NET collections and LINQ extension methods come with the option of specifying a custom IEqualityComparer. This adds a ton of flexibility, meaning that you can, for example, trivially customize OrderBy to be case-insensitive or Distinct() to compare only select properties of an object. Unfortunately, this flexibility is burdened by the  cumbersome effort of actually implementing IEqualityComparer, which is hard to do in under ~15 lines of code. Enter EqualityComparers.Create(), which makes it easy to define custom comparers on the fly using concise lambda expressions:

<pre>
public static class EqualityComparers
{
	public static IEqualityComparer<T> Create<T>(Func<T, T, bool> equals, Func<T, int> hash = null)
	{
		return new FuncEqualityComparer<T>(equals, hash ?? (t => 1));
	}

    private class FuncEqualityComparer<T> : EqualityComparer<T>
	{
		private readonly Func<T, T, bool> equals;
		private readonly Func<T, int> hash;
	
		public FuncEqualityComparer(Func<T, T, bool> equals, Func<T, int> hash)
		{
		    this.equals = equals;
			this.hash = hash;
		}
	
		public override bool Equals(T a, T b)
		{
			return a == null 
				? b == null 
				: b != null && this.equals(a, b);
		}
		
		public override int GetHashCode(T obj)
		{
			return obj == null ? 0 : this.hash(obj);
		}
	}
}
</pre>

For example, to create a dictionary that compares Tuples by only their first member, you can do:
<pre>
var dict = new Dictionary<Tuple<int, int>, object>(EqualityComparers.Create<int>(equals: (a, b) => a.Item1 == b.Item1, hash: t => t.Item1);
</pre>

Null values are handled automatically, which simplifies the implementation. Providing a hash function is optional, since implementing GetHashCode() may or may not be useful depending on the algorithm using the comparer. Even when it is useful, a custom hash function is only an optimization, which may not be necessary in some cases. Finally, the common case of creating a comparer that compares values by some key selector function can be implemented on top of this as a 1-liner:

<pre>
public static IEqualityComparer<T> Create<T, TKey>(Func<T, TKey> keySelector)
{
	return Create<T>(equals: (a, b) => EqualityComparer<TKey.Default.Equals(keySelector(a), keySelector(b)), hash: t => EqualityComparer<TKey>.Default.GetHashCode(keySelector(t)));
}
</pre>

* Capped()

For some reason, I always find Max() and Min() to be confusing when trying to bound values, likely because you need Min() to set an upper bound and Max() to set a lower bound. Hence, I use a Capped() extension
method to handle the common case of bounding a value within a range:

<pre>
public static T Capped<T>(this T @this, T? min = null, T? max = null)
	where T : struct, IComparable<T>
{
	return min.HasValue && @this.CompareTo(min.Value) < 0 ? min.Value
		: max.HasValue && @this.CompareTo(max.Value) > 0 ? max.Value
		: @this;
}
</pre>

For example, bounding an integer to between 1 and 10 becomes:
<pre>var bound = value.Capped(min: 1, max: 10);</pre>
Instead of the (in my opinion) far-less-readable:
<pre>var bound = Math.Max(1, Math.Min(value, 10));</pre>

* As<T>

This method is essentially a type-safe, inline cast. Just looking at the implementation,
it seems completely pointless:

<pre>
public static T As<T>(this T @this) { return @this; }
</pre>

However, there are a several places where this method can come in handy. One is type
inference. For example, you may have run into this problem:

<pre>
// the compiler complains that 'Type of conditional expression cannot be 
// determined because there is no implicit conversion between 
// 'System.Collections.Generic.List<int>' and 'System.Collections.Generic.HashSet<int>''
ICollection<int> collection = someCondition ? new List<int>() : new HashSet<int>();
</pre>

The common fix is to add a cast:

<pre>
ICollection<int> collection = someCondition ? (ICollection<int>)new List<int>() : new HashSet<int>();
</pre>

However, this is ugly because we are using a cast for what is really a type-safe operation: we know that the
cast is guaranteed to succeed. However, since there's no way to specify that, someone could swap out "new List<int>()"
for "new object()" and things would still compile: we've essentially given up some type-safety!

As() fixes this for us:

<pre>
// compiles
ICollection<int> collection = someCondition ? new List<int>().As<ICollection<int>>() : new HashSet<int>();

// does not compile (since the "this" parameter of As must be of type T... in this case ICollection<int>)
ICollection<int> collection = someCondition ? new object().As<ICollection<int>>() : new HashSet<int>();
</pre>

Another common use is when dealing with explicitly implemented interfaces. For example, let's say
you wanted to access the ICollection.SyncRoot property on a List<int>:

<pre>
// doesn't compile: SyncRoot is explicitly implemented and therefore private
var syncRoot = new List<int>().SyncRoot;

// ugly and not type-safe
var syncRoot = ((ICollection)new List<int>()).SyncRoot;

// type-safe, but takes 2 lines and isn't chainable
ICollection collection = new List<int>();
var syncRoot = collection.SyncRoot

// type-safe, 1 line!
var syncRoot = new List<int>().As<ICollection>().SyncRoot;
</pre>

* Traverse.Along
I've generally found that the LinkedList<T> data structure available in the BCL rarely comes up in everyday coding; in nearly all cases List<T> or IEnumerable<T> is preferable. That said, code I work with is often full of "natural" linked lists, such as the BaseType property on Type or the InnerException property on Exception. This handy method, which I adapted from some code I saw while browsing the Autofac (TODO add link) codebase, makes it easy to work with these structures as IEnumerables without having to go through a cumbersome conversion loop each time:
<pre>
public static class Traverse
{
	public static IEnumerable<T> Along<T>(T node, Func<T, T> next)
		where T : class
	{
		for (var current = node; current != null; current = next(current))
		{
			yield return current;
		}
	}
}
</pre>

With Along(), finding a (possible) inner SqlException from an Exception becomes:

<pre>
catch (Exception ex)
{
    var sqlException = Traverse.Along(ex, e => e.InnerException)
		.OfType<SqlException>()
		.FirstOrDefault();
}
</pre>

Given this structure, it's easy to imagine similar utilities for doing depth-first, breadth-first, and other traversals of arbitrary tree-like data structures.

* CollectionEquals

Frustratingly, the BCL doesn't contain a nice method for comparing collections. ISet has a SetEquals method that, by definition, ignores duplicates, while Enumerable.SequenceEqual is useful only when order matters. Here's a simple implementation of CollectionEquals, which checks whether two sequences have the same elements independent of order:

<pre>
public static bool CollectionEquals<T>(this IEnumerable<T> @this, IEnumerable<T> that, IEqualityComparer<T> comparer = null)
{
	// this is optional; if you want to be consistent with SequenceEqual, just throw exceptions if either argument is null instead
	if (@this == null) { return that == null; }
	else if (that == null) { return false; }
	
	var countedItems = @this.GroupBy(t => t, comparer).ToDictionary(g => g.Key, g => g.Count(), comparer);
	foreach (var item in that)
	{
		int count;
		if (!countedItems.TryGetValue(item, out count)) { return false; }
		if (count - 1 == 0) { countedItems.Remove(item); }
		else { countedItems[item] = count - 1; }
	}
	return countedItems.Count == 0;
}
</pre>

There are obviously many ways to write this; this one is fairly concise and O(N + M) time assuming that we have a good hash function for the collection elements. The other nice thing about this implementation is that it's very easy to evolve into an Assert utility for checking collection equality in unit tests. With natural points for capturing (1) items in @this and not in that and (2) items in that and not in @this, it's easy to fail with a very helpful error message explaining why the mismatch occurred.

* GetOrAdd
Dictionaries are frequently used for caching and memoization. You've no doubt come across the following pattern in code:

<pre>
SomeType value;
if (!dictionary.ContainsKey(key))
{
	value = ComputeValue(key);
	dictionary[key] = value;
}
else 
{
	value = dictionary[key];
}
</pre>

While this code can be made a bit more efficient with TryGetValue, it's still not chainable and ends up being written over and over again. Interestingly, the ConcurrentDictionary
class has a nice wrapper for this logic called GetOrAdd(), which takes a key and a value factory function so that this operation becomes a chainable one-liner. I've written an extension which grants this functionality to all IDictionaries:

<pre>
public static TValue GetOrAdd<TKey, TValue>(this IDictionary<TKey, TValue> @this, TKey key, Func<TKey, TValue> valueFactory)
{
	TValue value;
	if (!@this.TryGetValue(key, out value)) { @this.Add(key, value = valueFactory(key)); }
	return value;
}
</pre>

With this, the pattern above reduces to:
<pre>
var value = dictionary.GetOrAdd(key, ComputeValue);
</pre>

Note that I've explicitly made the signature of this function identical to the one on ConcurrentDictionary. That way, users of ConcurrentDictionary will not mistakenly use this function, which is not thread-safe (due to the use of Add) and would likely do more synchronization work than the builtin method. 

* GetGenericArguments

System.Type already has a GetGenericArguments() method, so why do we need another one? Using the native GetGenericArguments() in generic code can be difficult because a single type can have multiple sets of generic parameters. For example, IDictionary<int, int> implements IEnumerable<KeyValuePair<int, int>>. Thus, if you use the following code to determine the element type of an IEnumerable<T>, it will fail if the given enumerable is a Dictionary<int, int>:

<pre>
// returns typeof(int) for a Dictionary<int, int>, instead of the desired
// typeof(KeyValuePair<int, int>)
var elementType = enumerable.GetType().GetGenericArguments()[0];
</pre>

The GetGenericArguments() below method makes it easy to do this kind of logic robustly by allowing you to specify which generic type definition you actually care about when fetching generic arguments:

<pre>
public static Type[] GetGenericArguments(this Type @this, Type genericTypeDefinition)
{
	if (genericTypeDefinition.IsInterface)
	{
		var @interface = @this.GetInterfaces().FirstOrDefault(i => i.IsGenericType && i.GetGenericTypeDefinition() == genericTypeDefinition);
		return @interface.NullSafe(i => i.GetGenericArguments(), Type.EmptyTypes);
	}
	if (@this.IsGenericType && @this.GetGenericTypeDefinition() == genericTypeDefinition)
	{
		return @this.GetGenericArguments();
	}
	return @this.BaseType.NullSafe(t => t.GetGenericArguments(genericTypeDefinition), Type.EmptyTypes);
}
</pre>

Using this function, we can fix our element type-fetching code above:

<pre>
var elementType = enumerable.GetType().GetGenericArguments(typeof(IEnumerable<>));
</pre>

This functionality can also be used to test whether a given type extends or implements some generic type:

<pre>
// this doesn't work, since it returns false
var isIDictionary = typeof(IDictionary<,>).IsAssignableFrom(typeof(Dictionary<int, int>))

// this works correctly
var isIDictionary = typeof(Dictionary<int, int>).GetGenericArguments(typeof(IDictionary<,>)).Any();
</pre>

Even when the native GetGenericArguments() will always work correctly, I find myself using this
version where possible for enhanced readability. Deep in reflection code, it quickly becomes easy to forget which types you're
actually dealing with. Specifying the generic type definition makes the code more readable because it's more obvious
what the result will be:

<pre>
var returnType = someParameterInfo.GetGenericArguments()[2] // not that readable
var returnType = someParameterInfo.GetGenericArguments(typeof(Func<,,>))[2] // more readable
</pre>