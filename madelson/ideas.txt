Compartmentalization vs. Extensibility
- problem examples (e. g. analytic engine, stuff keeps leaking in due to business requirements)
- premature extraction of code -> core becomes a mess
- general-purpose widgets -> they want something else in the middle

Extensible APIs:
	- grouping ids (for analysis)
	- events for widgets
	- solves the 80% use-case, but is imperfect

Delay compartmentalization
	- e. g. start with a private helper method, not a separate class. Over time, it will prove out whether this is the right split

Build powerful utilities, and then "script" your business code
	- put your design effort into utilities so that all the common non-business concerns become easy. Domain code can then be underdesigned; it's just a 
	"script" and is 100% domain-focused
	- easier to design good utilities in well-established domains

_________________________________

The return of the delegate
- history of C# delegates
- named parameters
- descriptive type name
- optional, out, and ref parameters

__________________________________________

unit testing for MVC controllers
* the controller should be part of the routing engine => it should not have business logic
* controller is really MVC's abstraction for an entry point. Testing it without the web stack is like testing Linq to entities with linq to objects; it's simply not the same!
* too much to mock => model state, url helper, request. Even if you get a test running it can easily become fragile
* many controller errors are model-binding errors, serialization errors, or errors in the interaction between the controller and views; and many tests don't catch these
* unit test through selenium or phantom JS
	- end-to-end tests catch more real bugs because they test the controller in the context that it's actually used
* test your IOC wiring